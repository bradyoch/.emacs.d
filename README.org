#+TITLE: Brady's Emacs Configuration
#+AUTHOR: Brady Ochse

* Introduction

This file uses org-mode to create a literate configuration for
Emacs. The idea behind literate files is to allow a mix of both text
and code. In a way, it flips the traditional code file structure focus
primarily on text with code mixed in. It allows the author of the file
to discuss the purpose and thought process behind the code in a more
natural way.

To that end, this file describes all the configuration and tweaks that
I have made to Emacs while using it.

* Literate Setup

As discussed in the introduction, this is a literate config, which
means that it mixes normal prose and code block that the prose
describes. Org mode makes this extremely easy to set up, but there are
a couple of setup items we'll want to establish to make our lives
easier.

The first is to define a global variable that identifies this
file. We'll use this in other functions to refer to this file.

#+begin_src emacs-lisp
	(defvar user-literate-config
		(expand-file-name "README.org" user-emacs-directory)
		"Location of the user's literate config file.")
#+end_src

Next we'll set up the code to 'tangle' this configuration. In the
language of literate configurations, 'tangling' means extracting the
code blocks and 'weaving' them together into the code files that are
actually run by emacs.

#+begin_src emacs-lisp
  (defun brady/tangle-config ()
    (interactive)
    (org-babel-tangle-file user-literate-config user-init-file))
#+end_src

Now we can call ~brady/tangle-config~ to update both init.el and
early-init.el with the modifications made to this file. However, we'd
like to be able to always make sure that Emacs is updated whenever we
restart. I've seen a couple ways of doing this; however, the way that
I'm using (for now at least) is to defer automatic updates to just
before shutting down. This ensures that everything is ready when I
startup Emacs again and I keep my startup scripts fast on boot.

To do this, we first write a function that runs ~brady/tangle-config~
only when my literate config file is newer than the init file. This
does assume that I will not edit my init file by hand, but we can
always run ~brady/tangle-config~ manually if needed.

#+begin_src emacs-lisp
  (defun brady/rebuild-config-maybe ()
    (interactive)
    (when (file-newer-than-file-p user-literate-config user-init-file)
      (brady/tangle-config)))
#+end_src

Then all we need to do is add the above function to the
~kill-emacs-hook~ which runs before emacs is shut down.

#+begin_src emacs-lisp
  (add-hook 'kill-emacs-hook #'brady/rebuild-config-maybe)
#+end_src

* Packaging

Although I try to minimize the amount of third-party packages that I
use in my Emacs configuration, there are a ton of extremely high
quality packages that are available. Emacs comes with package.el to
download and install packages from GNU ELPA. You can configure
package.el to pull from other repositories as well. However, for this
particular configuration, I will be using straight.el.

** Straight.el

Straight.el is a more functional alternative to package.el. Instead of
pulling the packages from a centralized package repoostory, it pulls
the packages from the version controlled repositories directly.

#+begin_src emacs-lisp
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+end_src

Since straight.el replaces package.el, we need to include a snippet to
make sure that package.el is not loaded. This has to go in the
early-init.el file because otherwise package.el will be loaded before
init.el (where most other things in this file are exported to) can be
loaded.

#+begin_src emacs-lisp :tangle early-init.el
  (setq package-enable-at-startup 'nil)
#+end_src

** Use Package

use-package is an Emacs package that allows for more declarative and
contained configurations of other packages.

The first thing we need to do is install use-package. Fortunately,
straight.el makes that very easy.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
#+end_src

* Emacs Defaults

There are a good number of Emacs settings that I prefer to
change. This section is largely miscellaneous configuration items that
don't have a better home yet, but they all pertain to changing some
default behavior that comes with Emacs.

** GUI Elements

Emacs ships with some GUI elements that are quite helpful for getting
new people comfortable with the editor, but I find to be unnecessary,
so I disable them!

Note that these changes are going into the early-init file because
changing the settings there prevents Emacs from flickering while
loading.

#+begin_src emacs-lisp :tangle early-init.el
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src

** Autosaving and Backups

Autosaving and backups are nice features, but I prefer to have them
off.

#+begin_src emacs-lisp
	(setq auto-save-default 'nil
				make-backup-files 'nil
				create-lockfiles 'nil)
#+end_src

** Formatting

This section changes the formatting settings for Emacs as well as
adding some additional functionality.

*** Whitespace

Although I philosophically think that tabs are the correct indentation
unit, spaces seem to be becoming the standard for most things (that I
at least) work on so lets make them the standard in Emacs as well.

#+begin_src emacs-lisp
  (setq indent-tabs-mode 'nil)
  (setq-default tab-width 2)
#+end_src

Another really nice function of most editors nowadays is the ability
to cleanup whitespace after a line as well as empty lines at the end
of the file. We can make some quick tweaks to make that available in
Emacs as well.

#+begin_src emacs-lisp
  (setq-default delete-trailing-lines 't
		require-final-newline 't)
#+end_src

#+begin_src emacs-lisp
  (defun brady/cleanup-whitespace-in-buffer ()
    "Cleanup whitespace in the current buffer"
    (interactive)
    (when (derived-mode-p 'prog-mode 'text-mode)
      (delete-trailing-whitespace)))

  (add-hook 'before-save-hook #'brady/cleanup-whitespace-in-buffer)
#+end_src

** Custom

Custom is a system for configuring packages and settings using a
GUI. I think custom is a good idea, but I don't like that it clutters
my init.el file with variables that I didn't set. We'll use custom to
set custom to use a different file.

#+begin_src emacs-lisp
  (use-package custom
    :config
    (when (file-exists-p custom-file)
      (load-file custom-file))
    :custom
    (custom-file (expand-file-name "custom.el" user-emacs-directory)))
#+end_src

** Bell

Prevent all types of bell ringing on error.

#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Memory thresholds

Increase the maximum garbage collection threshold to prevent the UI
from blocking as often. Also increate the maximum read-process-output
to allow for language servers to function better.

#+begin_src emacs-lisp
	(setq gc-cons-threshold (* 50 1024 1024)
				read-process-output-max (* 1024 1024))
#+end_src

** Startup

When Emacs starts up, it displays a useful page about how to get
started with it. I prefer to skip that and go directly to a scratch
buffer.

#+begin_src emacs-lisp
	(setq inhibit-startup-screen 't
				initial-scratch-message "")
#+end_src

** Misc

A section for other tweaks that aren't large enough for their own
discussion.

*** Completion

Emacs has pretty good completion built-in. I have used company in the
past for a more modern completion framework, but I'm trying the
defaults for now. The only tweak I've made so far is to set
~tab-always-indent~ to ~'complete~ which triggers completion if the
current line is already indented.

#+begin_src emacs-lisp
	(setq tab-always-indent 'complete)
#+end_src

* Packages

This section contains packages that are not associated with a single
programming language. For programming language specific packages, see
the Languages section of this config.

** Magit

Magit is a fantastic interface to all things git.

#+begin_src emacs-lisp
  (use-package magit
    :straight t
    :bind ("C-x g" . magit))
#+end_src

** Avy Jump

Avy jump allows me to jump to any place in my open frame with a couple
key presses. It's a really cool package that makes navigating the
Emacs interface much easier.

#+begin_src emacs-lisp
  (use-package avy
    :straight t
    :bind ("M-SPC" . avy-goto-word-or-subword-1))
#+end_src

** Eglot

Eglot is a language server client that tries to integrate with the
built-in functionality of Emacs. lsp-mode generally has slightly more
features, but I've been happy with Eglot.

#+begin_src emacs-lisp
	(use-package eglot
		:straight t
		:config
		(setq eglot-confirm-server-initiated-edits 'nil))
#+end_src

** Highlight Line

hl-line is a package that is built in to Emacs the simply highlights
the line that the cursor is currently on.

#+begin_src emacs-lisp
  (use-package hl-line
    :init (global-hl-line-mode 1))
#+end_src

** Display Line Numbers

display-line-numbers is a package that is built in to Emacs that
displays the line numbers to the side of the buffer. I prefer to only
have it enabled for programming buffers.

#+begin_src emacs-lisp
  (use-package display-line-numbers
    :hook (prog-mode . display-line-numbers-mode))
#+end_src

** VTerm

There are a number of great shells in Emacs. Eshell is personally my
favorite of them, but sometimes you need to run a program that doesn't
behave well with any of the built-in shells and you need a full
shell. VTerm is that for Emacs.

#+begin_src emacs-lisp
	(use-package vterm
		:straight t)
#+end_src

* Languages

This section contains all the configuration for programming languages
that I use in Emacs.

** Python

I am mostly happy with the default python support so this section is
only here for completeness. I have no specific configuration for
python yet.

** Javascript/Typescript

The javascript support in Emacs is pretty good. However, we do need to
install the typescript-mode package to make Emacs work with typescript
files. I choose not to use the tide package which integrates with the
typescript language server. Instead, I simply use eglot and the
typescript-language-server which I find to be slightly more standard.

#+begin_src emacs-lisp
  (use-package typescript-mode
    :straight t
    :config
    (setq-default typescript-indent-level 2))

  (use-package js
    :config
    (setq-default js-indent-level 2))
#+end_src

** HTML/CSS

I haven't found a need for web-mode yet, but I want to mention it in
case I determine I have a need for it in the future. However, I do
want to customize some CSS to make indent levels consistent.

#+begin_src emacs-lisp
  (use-package css-mode
    :config
    (setq-default css-indent-offset 2))
#+end_src

* Keybindings

This section contains all keybindings that are unrelated to a specific
major mode.

Firstly, we disable C-z to prevent the GUI from suspending. I
typically don't want to do this, and if I did, I would use the window
manager to do it.

#+begin_src emacs-lisp
  (global-unset-key (kbd "C-z"))
#+end_src

* Org Mode

Org mode is a life manager centered around a markup language that this
file is written in!

#+begin_src emacs-lisp
	(use-package org
		:straight t
		:config
		(add-to-list 'org-structure-template-alist
								 '("el" . "src emacs-lisp"))
		:custom
		(org-adapt-indentation 'nil "Don't indent text to match headings"))

	(use-package org-tempo
		:after org)
#+end_src
